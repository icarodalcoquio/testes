#!/usr/bin/env python3
"""Executa transposição de NCM a partir de um único template com 3 abas.

Estrutura esperada no arquivo de entrada:
- Página 2: NCM antigas + descrição + categoria de desgravação/stage
- Página 1: NCM novas + descrição
- Página 3: tabela de correlação NCM antiga -> NCM nova

Saída:
- arquivo novo "transposição executada.xlsx" (ou nome informado em --out),
  contendo todas as abas e a Página 1 enriquecida com os resultados.
"""

from __future__ import annotations

import argparse
import re
from typing import Iterable



def pad8(x):
    import numpy as np
    if x is None:
        return None
    if isinstance(x, float) and np.isnan(x):
        return None
    s = str(x).strip()
    s = re.sub(r"\.0$", "", s)
    digits = re.sub(r"\D", "", s)
    if digits == "":
        return None
    return digits.zfill(8)


def find_col(df: pd.DataFrame, patterns: Iterable[str]):
    for c in df.columns:
        name = str(c)
        for p in patterns:
            if re.search(p, name, flags=re.I):
                return c
    return None


def parse_fp(stage):
    if stage is None:
        return None
    s = str(stage).strip().upper()
    m = re.fullmatch(r"FP(\d+)%Y(\d+)", s)
    if not m:
        return None
    return int(m.group(1)), int(m.group(2))


def choose_stage_conservative(stages):
    clean = [str(s).strip().upper() for s in stages if s is not None and str(s).strip() != ""]
    if not clean:
        return ""
    if len(set(clean)) == 1:
        return clean[0]
    if "E" in clean:
        return "E"
    if "TRQ" in clean:
        return "TRQ"

    fp_pairs = [parse_fp(s) for s in clean]
    fp_pairs = [t for t in fp_pairs if t is not None]
    if fp_pairs:
        pct_min = min(p for p, _ in fp_pairs)
        yr_max = max(y for p, y in fp_pairs if p == pct_min)
        return f"FP{pct_min}%Y{yr_max}"

    nums = [int(s) for s in clean if re.fullmatch(r"\d+", s)]
    if nums:
        return str(max(nums))

    if "FREE" in clean:
        return "FREE"

    return clean[0]


def stage_to_cronograma(stage):
    if stage is None or str(stage).strip() == "":
        return ""
    s = str(stage).strip().upper()
    if s == "FREE":
        return "Duty free"
    if s == "E":
        return "Excluded"
    if s == "TRQ":
        return "TQR"
    if re.fullmatch(r"\d+", s):
        return s
    m = re.fullmatch(r"FP(\d+)%Y(\d+)", s)
    if m:
        pct = int(m.group(1))
        year = int(m.group(2))
        if year == 0:
            return f"Tariff preference of {pct}%"
        return f"Tariff preference of up to {pct}%"
    return str(stage).strip()


def build_transposicao(input_path: str, out_path: str, aba_novas: str, aba_antigas: str, aba_corr: str):
    import pandas as pd
    xls = pd.ExcelFile(input_path)
    sheets = {name: pd.read_excel(input_path, sheet_name=name) for name in xls.sheet_names}

    if aba_novas not in sheets:
        raise ValueError(f"Aba de NCM novas não encontrada: '{aba_novas}'")
    if aba_antigas not in sheets:
        raise ValueError(f"Aba de NCM antigas não encontrada: '{aba_antigas}'")
    if aba_corr not in sheets:
        raise ValueError(f"Aba de correlação não encontrada: '{aba_corr}'")

    df_new = sheets[aba_novas].copy()
    df_old = sheets[aba_antigas].copy()
    df_corr = sheets[aba_corr].copy()

    # limpa colunas vazias comuns de Excel
    df_new = df_new.loc[:, ~df_new.columns.astype(str).str.match(r"^Unnamed")]
    df_old = df_old.loc[:, ~df_old.columns.astype(str).str.match(r"^Unnamed")]
    df_corr = df_corr.loc[:, ~df_corr.columns.astype(str).str.match(r"^Unnamed")]

    # detecta colunas-chave
    col_old_code = find_col(df_old, [r"^Tariff\s*Line$", r"\bncm\b", r"tariff", r"codigo", r"código"])
    col_old_stage = find_col(df_old, [r"staging", r"categoria", r"category", r"desgrav", r"cronograma"])
    col_old_desc = find_col(df_old, [r"descri", r"description", r"descripcion", r"descrição"])

    col_new_code = find_col(df_new, [r"\bncm\b", r"tariff", r"codigo", r"código"])
    col_new_desc = find_col(df_new, [r"descri", r"description", r"descripcion", r"descrição"])

    col_c_old = find_col(df_corr, [r"^NCM_2012$", r"2012", r"old", r"orig"])
    col_c_new = find_col(df_corr, [r"^NCM_2017$", r"2017", r"2021", r"new", r"dest"])

    if col_old_code is None or col_old_stage is None:
        raise ValueError(f"Na '{aba_antigas}', não achei colunas de código/categoria. code={col_old_code}, stage={col_old_stage}")
    if col_new_code is None:
        raise ValueError(f"Na '{aba_novas}', não achei coluna de NCM/código.")
    if col_c_old is None or col_c_new is None:
        raise ValueError(f"Na '{aba_corr}', não achei colunas old/new. old={col_c_old}, new={col_c_new}")

    if col_old_desc is None:
        df_old["__desc_old__"] = ""
        col_old_desc = "__desc_old__"
    if col_new_desc is None:
        df_new["__desc_new__"] = ""
        col_new_desc = "__desc_new__"

    old = df_old[[col_old_code, col_old_stage, col_old_desc]].copy()
    old.columns = ["code_old", "stage_old", "desc_old"]
    old["code_old"] = old["code_old"].apply(pad8)
    old["stage_old"] = old["stage_old"].astype(str).str.strip()
    old["desc_old"] = old["desc_old"].astype(str).str.strip()
    old = old.dropna(subset=["code_old"]).drop_duplicates(subset=["code_old"])

    stage_by_old = old.set_index("code_old")["stage_old"].to_dict()

    corr = df_corr[[col_c_old, col_c_new]].copy()
    corr.columns = ["old", "new"]
    corr["old"] = corr["old"].apply(pad8)
    corr["new"] = corr["new"].apply(pad8)
    corr = corr.dropna().drop_duplicates()
    corr_use = corr[corr["old"].isin(stage_by_old.keys())].copy()

    parents_by_new = corr_use.groupby("new")["old"].apply(lambda s: sorted(set(s.dropna()))).to_dict()

    new_all = df_new.copy()
    new_all["__code_new__"] = new_all[col_new_code].apply(pad8)

    def compute(code_new):
        if not code_new:
            return "", "", 0, ""
        parents = parents_by_new.get(code_new, [])
        stage = choose_stage_conservative([stage_by_old.get(p, "") for p in parents]) if parents else ""
        cron = stage_to_cronograma(stage) if stage else ""
        return ",".join(parents), stage, len(parents), cron

    calc = new_all["__code_new__"].apply(compute).apply(pd.Series)
    calc.columns = [
        "Referência NCM antigas",
        "Categoria desgravação escolhida",
        "Qtd pais",
        "Cronograma escolhido",
    ]

    pagina1_result = pd.concat([new_all, calc], axis=1)

    # grava novo arquivo mantendo abas e substituindo Página 1 enriquecida
    with pd.ExcelWriter(out_path, engine="openpyxl") as writer:
        for name, df in sheets.items():
            if name == aba_novas:
                pagina1_result.to_excel(writer, sheet_name=name, index=False)
            else:
                df.to_excel(writer, sheet_name=name, index=False)

    print(f"Arquivo gerado: {out_path}")
    print(f"Aba processada: {aba_novas}")
    print(f"Linhas processadas: {len(pagina1_result)}")


def main():
    parser = argparse.ArgumentParser(description="Executa a transposição de desgravação a partir de um template único.")
    parser.add_argument("--input", default="template transp.xlsx", help="Arquivo template com Página 1/2/3")
    parser.add_argument("--out", default="transposição executada.xlsx", help="Arquivo de saída")
    parser.add_argument("--aba-novas", default="Página 1", help="Aba com NCM novas")
    parser.add_argument("--aba-antigas", default="Página 2", help="Aba com NCM antigas + categorias")
    parser.add_argument("--aba-corr", default="Página 3", help="Aba com correlação oficial")
    args = parser.parse_args()

    build_transposicao(
        input_path=args.input,
        out_path=args.out,
        aba_novas=args.aba_novas,
        aba_antigas=args.aba_antigas,
        aba_corr=args.aba_corr,
    )


if __name__ == "__main__":
    main()
